from datetime import datetime
import pytest
from unittest.mock import patch, MagicMock, call
from yoctales.cmd import (
    extract_git_repo_name_from_uri,
    CommandFailed,
    CommandShell,
    CommandGitClone,
    CommandExecuteInShellScript,
)


# Tests for extract_git_repo_name_from_call
@pytest.mark.parametrize(
    "uri, expected_name",
    [
        ("git://git.openembedded.org/meta-openembedded", "meta-openembedded"),
        ("git://git.yoctoproject.org/poky", "poky"),
        ("git@github.com:marifante/super_repo.git", "super_repo"),
        ("https://github.com/example/repo.git", "repo"),
        ("ssh://git@github.com/example/repo", "repo"),
        ("invalid-uri", ""),
        ("not-a-valid git url", ""),
        ("", ""),
    ],
)
def test_extract_git_repo_name_from_uri(uri, expected_name):
    """Test extract_git_repo_name_from_call with various URIs."""
    assert extract_git_repo_name_from_uri(uri) == expected_name


def test_command_shell_execute_success():
    """Test successful execution of a shell command."""
    with patch("yoctales.cmd.execute_in_shell", return_value=(None, None, 0, False)) as exec_in_shell_mock:
        cmd = CommandShell(name="test", call="echo 'Hello'", cwd=".")
        cmd.execute()

        exec_in_shell_mock.assert_called_once_with(call="echo 'Hello'", cwd=".", shell=False)


def test_command_shell_execute_command_not_found():
    """Test failure of a shell command when the command is not found."""
    with patch("yoctales.cmd.execute_in_shell", return_value=(None, None, 0, True)):
        cmd = CommandShell(name="test", call="nonexistent_command", cwd=".")
        with pytest.raises(CommandFailed, match="Command not found"):
            cmd.execute()


def test_command_shell_execute_failure():
    """Test failure of a shell command with a non-zero exit code."""
    with patch("yoctales.cmd.execute_in_shell", return_value=(None, None, 1, False)):
        cmd = CommandShell(name="test", call="invalid_command", cwd=".")
        with pytest.raises(CommandFailed, match="Exit code is not zero"):
            cmd.execute()


@pytest.mark.parametrize(
    "name, call, cwd, expected_str",
    [
        ("test1", "echo 'Hello'",   ".",            "test1                     : .                                   : echo 'Hello'"),
        ("test2", "ls -la",         "/home/user",   "test2                     : /home/user                          : ls -la"),
        ("test3", "pwd",            None,           "test3                     : .                                   : pwd"),
    ],
)
def test_command_shell_str(name, call, cwd, expected_str):
    """Test the string representation of the CommandShell class."""
    cmd = CommandShell(name=name, call=call, cwd=cwd if cwd else ".")
    assert str(cmd) == expected_str


def test_command_git_clone_execute_repo_not_cloned_yet():
    """Test cloning a Git repository when it does not already exist."""
    with patch("yoctales.cmd.execute_in_shell", return_value=(None, None, 0, False)) as exec_in_shell_mock, \
         patch("yoctales.cmd.os.path.isdir", return_value=False) as isdir_mock:
            cmd = CommandGitClone(name="clone", uri="git://git.yoctoproject.org/poky", revision="master", cwd=".")
            cmd.execute()

            exec_in_shell_mock.assert_called_once_with(
                call='git clone git://git.yoctoproject.org/poky -b master', cwd='.', shell=False)
            isdir_mock.assert_called_once_with("./poky/.git")


def test_command_git_clone_execute_repo_already_clonedt():
    """Test cloning a Git repository when it already exists (no git clone executed)."""
    with patch("yoctales.cmd.execute_in_shell") as exec_in_shell_mock, \
         patch("yoctales.cmd.os.path.isdir", return_value=True) as isdir_mock:
            cmd = CommandGitClone(name="clone", uri="git://git.yoctoproject.org/poky", revision="master", cwd=".")
            cmd.execute()

            assert exec_in_shell_mock.called is False
            isdir_mock.assert_called_once_with("./poky/.git")


def test_command_execute_in_shell_script_creation():
    """Test creation of a temporary shell script for execution."""
    fixed_date = datetime(2025, 5, 6, 12, 0, 0)
    call_inside_script = "echo 'Hello' && my_super_command --option1 super_arg1 --option2 324123\n"
    expected_file_content = f"#!/bin/bash\n# Auto-generated by yoctales on 2025-05-06 12:00:00\n{call_inside_script}"
    expected_tmp_script_path = "./script_tmp_script"

    with patch("yoctales.cmd.datetime") as datetime_mock, \
         patch("yoctales.cmd.os.chmod") as chmod_mock, \
         patch("yoctales.cmd.os.stat", return_value=MagicMock(st_mode=0x644)) as stat_mock, \
         patch("yoctales.cmd.open", MagicMock()) as open_mock:

        datetime_mock.now.return_value = fixed_date

        CommandExecuteInShellScript(name="script", call=call_inside_script, cwd=".")

        chmod_mock.assert_called_once()
        stat_mock.assert_called_once_with(expected_tmp_script_path)
        assert open_mock.call_args_list[0] == call(expected_tmp_script_path, "w")
        open_mock().__enter__().write.assert_called_once_with(expected_file_content)
